# JavaScript 学习笔记 —— 作用域

> 本人水平有限，如有叙述不当或者错误之处，望各位指出，十分感谢！

### 作用域

我们要知道，在 JavaScript 中，作用域分为三种类型：

* **全局作用域**
* **函数作用域**
* **块级作用域**（很多人认为 JS 没有块级作用域，但其实是存在的！咱之后说明。）

##### 全局作用域

**全局作用域**，简而言之就是定义在所有函数外部，可以在程序任意地方访问到其中（全局）量的 **规则**（如浏览器窗体中可以随处访问 `window`；Web Service 或 Web Workers 中可以随处访问 `self`；Node.js 中可以随处访问 `global`）。

> 有趣的是 `window = null` 是无效操作，但是记这篇笔记时 `self = null`、`global = null` 是有效的，危险！


##### 函数作用域

**函数作用域**，这又是什么呢？这里我们先引入新概念：

* **词法作用域**（lexical scope / static scope）
* **动态作用域**（dynamic scope）

我们知道，浏览器有一个 JS 引擎线程，负责 **编译** 和 **运行** JS 代码。因为 JS 文件在浏览器中下载后就需要生效，这种情景需求使得浏览器中的 JS 是即时编译且即时执行的。其中编译阶段会有一个 **词法分析** 的过程，它读到函数声明时便会为此函数生成一个 **符号表**（Symbol Table，一种键值对形式的哈希表数据结构，保存了函数的作用域信息，包括标识符、内存地址、数据类型、内部变量等），如果函数内还嵌套了子函数，引擎便会为其生成一个子表，以此类推，形成一个树的结构，而一个符号表即为其节点。

这个过程是在编译时完成的，我们可以看到这里已经生成了一个树，而到执行阶段时，遇到 **取值操作** （RHS）时便会在其相应的符号表中进行查询操作，如果查找到了变量，就会将其值返回作为取值操作的结果；如果找不到，就顺着树的结构往上级节点（即，上级嵌套作用域）查询，直到找到这个变量对应的标识符，取得其值；否则，若到了根节点（全局作用域）都无法找到其值，就返回 `ReferenceError` 引用错误。

这时，我们发现自己似乎形成作用域的印象了。是的，**函数作用域** 就是上面所描述这样的 **词法作用域**，它在编译阶段就已经绑定了。

**动态作用域** 与之相对应，它不是在编译阶段绑定的，而是根据其 **调用** 时所在作用域来绑定当前作用域，与声明函数的位置无关。在 JS 中，只有 **词法作用域**，没有 **动态作用域**，但是 `this` 可以实现类似 **动态作用域** 的效果。这个详见有关 `this` 的笔记。

##### 块级作用域

**块级作用域** 在 JS 中比较特殊。我们

### 变量提升

只要是一个作用域，就会有 **变量提升** 这个规则。我们先来看一个例子：

```js
a(); // 3

// 函数声明
function a() {
    console.log(1);
}

// 函数表达式
var a = function () {
    console.log(2);
}
a(); // 2

function a() {
    console.log(3);
}
a(); // 2

// 具名函数表达式
var a = function a() {
    console.log(4);
}
a(); // 4
```

在这个例子中，我们可以看到输出的数字顺序好像杂乱无章，但其实理解 **变量提升** 这个概念后你就明白了。

我们知道 JS 在下载后分两个阶段——编译和执行阶段。在编译过程中，作用域会先记录下声明的标识符。比如 `var a = 1;` 这句话，在编译时相应作用域会记录下声明 `var a`， 不管这句话写在同一级作用域的哪里，都会在编译阶段就记录在了这个作用域中，这就相当于把声明提到了此作用域的最上面，形成了 **变量提升**。而后，进入一行一行执行阶段时，读到的是 `a = 1` 这样的 **赋值操作**（LHS），引擎便查询作用域中变量 `a` 的信息，将值写入其内存地址。我们可以看到，存在编译和执行这样的先后顺序，在同一作用域的前提下，不管变量声明写在哪里，都相当于写在了这个作用域的开头，这就是一种 **变量提升**。

这里的例子也是这样，只不过不是单纯的变量声明提升，而是针对函数。提到函数，就不得不说说定义函数的两种形式：

* 函数声明
* 函数表达式

**函数声明** 主要就是我们常用的定义函数方式，如例子中的注释所示。这样声明的函数在编译时作用域会记录下函数的标识符，同时将其标记为函数类型，并将函数内容等信息全部记录在这个标识符下。这样之后调用此函数便可以做到直接执行函数内容。但是我们知道 JS 没有显式支持 **重载** 这个机制，如果编译到后面，JS 引擎发现我们又声明了一次同样函数名的函数，便会直接覆盖之前的函数内容。这里，最后一个这样 **函数声明** 形式定义的同名函数输出 `3`，在编译阶段覆盖了之前声明的函数内容，那么第一行调用 `a()` 便会直接在作用域中查询到这个函数打印 `3`。

**函数表达式** 编译时待遇和上面 `var a = 1;` 差不多，编译时作用域只会记录下 **变量声明** `var a`，值为 `undefined`（不过在 JS 中，函数声明的 **优先级** 高于变量声明，所以这个 `undefined` 并没有覆盖之前的函数声明内容，否则的话第一行调用函数会报 `TypeError` 这个错误），等到执行赋值操作时，才会把后面的函数赋给这个变量，所以这个 **函数表达式** 之后执行的函数调用全为此 **函数表达式** 的内容——打印 `2`。

那么最后一个具名函数表达式是怎么回事呢？原来编译时因为作用域只会先记录下最后一个函数的 `var a`，而并不能记录下等号后具名函数的标识符 `a`，相当于这个具名函数的标识符是完全被忽略的，从下面这个例子我们就能看出这一点：

```js
a(); // TypeError
b(); // ReferenceError

var a = function b() {
    console.log(4);
}
a(); // 4
b(); // ReferenceError
```

##### let 和 const 的变量提升

当然，上面所说的变量声明使用的是关键词 `var`，那么 ES6 中的 `let` 和 `const` 是怎么处理变量提升的呢？

？？？？？？？？？？？？？？？？？？？？？

> 将 **变量提升** 的规则概括成一句话就是：“只有声明本身会被提升，而赋值或其它运行逻辑会留在原地。”

### 参考

\- [《你不知道的 JavaScript （上卷）》](https://book.douban.com/subject/26351021/)

\- [深入浅出ES6（十四）：let 和 const
](http://www.infoq.com/cn/articles/es6-in-depth-let-and-const/)

\- [知乎专栏 - 认识 V8 引擎](https://zhuanlan.zhihu.com/p/27628685)